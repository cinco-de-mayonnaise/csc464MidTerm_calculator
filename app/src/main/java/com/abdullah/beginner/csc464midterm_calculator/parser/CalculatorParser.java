/* CalculatorParser.java */
/* Generated by: ParserGeneratorCC: Do not edit this line. CalculatorParser.java */
package com.abdullah.beginner.csc464midterm_calculator.parser;

import java.math.*;
import com.abdullah.beginner.csc464midterm_calculator.Result;

public class CalculatorParser implements CalculatorParserConstants {

    private enum FunctionType {
        FUNCTION_SIN, FUNCTION_COS, FUNCTION_TAN, FUNCTION_ABS, FUNCTION_SQRT, FUNCTION_EXP, FUNCTION_LOG, FUNCTION_LN
    }

    private static boolean __allInstanceOf(Class<?> cls, Object... objs) {
        for (Object o : objs) {
            if (!cls.isInstance(o)) {
                return false;
            }
        }
        return true;
    }

    private static double[] __promoteResultsToDouble(Result... values) {
        double[] arr = new double[values.length];

        for (int i = 0; i < values.length; i++)
            arr[i] = values[i].getValue().doubleValue();

        return arr;
    }

    private static Result __addition(Result v1, Result v2) {
        if (__allInstanceOf(Long.class, v2.getValue(), v1.getValue()))
        {
            try {
                v1 = new Result(Math.addExact(v2.getValue().longValue(), v1.getValue().longValue()));

                return v1;
            }
            catch (ArithmeticException e)
            {
                // overflow, turn result into double... (in the future we will convert this to big int)
            }
        }

        double sum = 0;
        for (double v: __promoteResultsToDouble(v2, v1))
            sum += v;

        v1 = new Result(sum);

        return v1;
    }

    private static Result __subtraction(Result v1, Result v2) {
        // check if datatypes are same
        if (__allInstanceOf(Long.class, v2.getValue(), v1.getValue()))
        {
            try {
                v1 = new Result(Math.addExact(v1.getValue().longValue(), -v2.getValue().longValue()));

                return v1;
            }
            catch (ArithmeticException e)
            {
                // overflow, turn result into double... (in the future we will convert this to big int)
            }
        }

        double[] values = __promoteResultsToDouble(v1, v2);

        v1 = new Result(values[0] - values[1]);
        return v1;
    }

    private static Result __multiplication(Result v1, Result v2)
    {
        // check if datatypes are same
        if (__allInstanceOf(Long.class, v2.getValue(), v1.getValue()))
        {
            try {
                v1 = new Result(Math.multiplyExact(v2.getValue().longValue(), v1.getValue().longValue()));

                return v1;
            }
            catch (ArithmeticException e)
            {
                // overflow, turn result into double... (in the future we will convert this to big int)
            }
        }

        double[] values = __promoteResultsToDouble(v1, v2);
        v1 = new Result(values[0] * values[1]);

        return v1;
    }

    private static Result __exponential(Result v1, Result v2)
    {
        // check if datatypes are same
        if (__allInstanceOf(Long.class, v2.getValue(), v1.getValue()))
        {
            try {
                v1 = new Result((long)Math.pow(v1.getValue().doubleValue(), v2.getValue().doubleValue()));

                return v1;
            }
            catch (ArithmeticException e)
            {
                // overflow, turn result into double... (in the future we will convert this to big int)
            }
        }

        double[] values = __promoteResultsToDouble(v1, v2);
        v1 = new Result(Math.pow(values[0], values[1]));

        return v1;
    }

    private static Result __division(Result v1, Result v2) throws ArithmeticException
    {
        // check if datatypes are same
        if (__allInstanceOf(Long.class, v2.getValue(), v1.getValue()))
        {
            try {
                long val1 = v1.getValue().longValue();
                long val2 = v2.getValue().longValue();

                if (val1 % val2 != 0)
                    throw new ArithmeticException("Should handover this case to double!");

                return new Result(val1 / val2);   // also passes divide by 0 to double, which then gets handled by the double-case
            }
            catch (ArithmeticException e)
            {
                // overflow, turn result into double... (in the future we will convert this to big int)
            }
        }

        double[] values = __promoteResultsToDouble(v1, v2);

//        if (values[1] == 0.0)
//            throw new ParseException("Divide by zero!");     // let Java throw the error
        v1 = new Result(values[0] / values[1]);

        return v1;
    }

    private static Result __modulo(Result v1, Result v2) throws ArithmeticException
    {
        // check if datatypes are same
        if (__allInstanceOf(Long.class, v2.getValue(), v1.getValue()))
        {
            try {
                long val1 = v1.getValue().longValue();
                long val2 = v2.getValue().longValue();

                return new Result(val1 % val2);
            }
            catch (ArithmeticException e)
            {
                // overflow, turn result into double... (in the future we will convert this to big int)
            }
        }

        double[] values = __promoteResultsToDouble(v1, v2);

//        if (values[1] == 0.0)
//            throw new ParseException("Divide by zero!");    // let java throw error
        v1 = new Result(values[0] % values[1]);

        return v1;
    }

    private static Result __apply_function(Result v, FunctionType f) throws IllegalArgumentException
    {
        double ret;
        switch (f)
        {
            case FUNCTION_ABS:
                if (v.getType() == Long.class)
                    return new Result(Math.abs(v.getValue().longValue()));
                else if (v.getType() == Double.class)
                    return new Result(Math.abs(v.getValue().doubleValue()));
                throw new IllegalStateException("Code needs to be updated: Result value was neither Long or Double");
            case FUNCTION_SIN:
                ret = Math.sin(v.getValue().doubleValue());
                break;
            case FUNCTION_COS:
                ret = Math.cos(v.getValue().doubleValue());
                break;
            case FUNCTION_TAN:
                ret = Math.tan(v.getValue().doubleValue());
                break;
            case FUNCTION_EXP:
                ret = Math.exp(v.getValue().doubleValue());
                break;
            case FUNCTION_SQRT:
                ret = Math.sqrt(v.getValue().doubleValue());
                break;
            case FUNCTION_LOG:
                ret = Math.log10(v.getValue().doubleValue());
                break;
            case FUNCTION_LN:
                ret = Math.log(v.getValue().doubleValue());
                break;
            default:
                throw new IllegalArgumentException("Not Implemented");
        }

        if (ret % 1 == 0.0)
            return new Result((long)ret);
        else
            return new Result(ret);
    }

  final public Result Start() throws ParseException {Result value;
    value = Expression();
    jj_consume_token(0);
//System.out.println(value.getValue());
        //return jjtThis;  // DEBUG
        {if ("" != null) return value;}
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Result Expression() throws ParseException {Result value;
    Result temp;
    value = Term1();
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case PLUS:
    case MINUS:{
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case PLUS:{
        jj_consume_token(PLUS);
        temp = Expression();
value = __addition(value, temp);
        break;
        }
      case MINUS:{
        jj_consume_token(MINUS);
        temp = Expression();
value = __subtraction(value, temp);
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      ;
    }
{if ("" != null) return value;}
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Result Term1() throws ParseException {Result value;
    Result temp;
    value = Term2();
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case MULTIPLY:{
      jj_consume_token(MULTIPLY);
      temp = Term1();
value = __multiplication(value, temp);
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      ;
    }
{if ("" != null) return value;}
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Result Term2() throws ParseException {Result value;
    Result temp;
    value = Factor();
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case DIVIDE:
    case MODULO:{
      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
      case DIVIDE:{
        jj_consume_token(DIVIDE);
        temp = Term2();
value = __division(value, temp);
        break;
        }
      case MODULO:{
        jj_consume_token(MODULO);
        temp = Term2();
value = __modulo(value, temp);
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      ;
    }
{if ("" != null) return value;}
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Result Factor() throws ParseException {Result value;
    Result temp;
    value = Exponential();
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case POWER:{
      jj_consume_token(POWER);
      temp = Factor();
value = __exponential(value, temp);
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      ;
    }
{if ("" != null) return value;}
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Result Exponential() throws ParseException {Result value;
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      value = Expression();
      jj_consume_token(RPAREN);
      break;
      }
    case NUMBER_FP:
    case NUMBER_INT:
    case MINUS:
    case FUNCTION_SIN:
    case FUNCTION_COS:
    case FUNCTION_TAN:
    case FUNCTION_ABS:
    case FUNCTION_SQRT:
    case FUNCTION_EXP:
    case FUNCTION_LOG:
    case FUNCTION_LN:
    case CONST_PI:
    case CONST_E:{
      value = Value();
      break;
      }
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return value;}
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Result Value() throws ParseException {Result value;
    Result temp;
    int sign = 1;
    FunctionType function_call;
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case MINUS:{
      jj_consume_token(MINUS);
sign = -1;
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case FUNCTION_SIN:
    case FUNCTION_COS:
    case FUNCTION_TAN:
    case FUNCTION_ABS:
    case FUNCTION_SQRT:
    case FUNCTION_EXP:
    case FUNCTION_LOG:
    case FUNCTION_LN:{
      function_call = Function();
      jj_consume_token(LPAREN);
      temp = Expression();
      jj_consume_token(RPAREN);
value = __apply_function(temp, function_call);
      break;
      }
    case NUMBER_FP:
    case NUMBER_INT:{
      value = Number();
      break;
      }
    case CONST_PI:{
      jj_consume_token(CONST_PI);
value = new Result(Math.PI * sign); sign = 1;
      break;
      }
    case CONST_E:{
      jj_consume_token(CONST_E);
value = new Result(Math.E  * sign); sign = 1;
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if (sign == -1)
        {
            Number n = value.getValue();
            if (value.getType() == Long.class)
                value = new Result(n.longValue() * -1);
            else if (value.getType() == Double.class)
                value = new Result(n.doubleValue() * -1);
            else
                throw new IllegalStateException("Code needs to be updated: Result value was neither Long or Double");


        }
        {if ("" != null) return value;}
    throw new IllegalStateException ("Missing return statement in function");
}

  final public FunctionType Function() throws ParseException {
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case FUNCTION_ABS:{
      jj_consume_token(FUNCTION_ABS);
{if ("" != null) return FunctionType.FUNCTION_ABS;}
      break;
      }
    case FUNCTION_SIN:{
      jj_consume_token(FUNCTION_SIN);
{if ("" != null) return FunctionType.FUNCTION_SIN;}
      break;
      }
    case FUNCTION_COS:{
      jj_consume_token(FUNCTION_COS);
{if ("" != null) return FunctionType.FUNCTION_COS;}
      break;
      }
    case FUNCTION_TAN:{
      jj_consume_token(FUNCTION_TAN);
{if ("" != null) return FunctionType.FUNCTION_TAN;}
      break;
      }
    case FUNCTION_EXP:{
      jj_consume_token(FUNCTION_EXP);
{if ("" != null) return FunctionType.FUNCTION_EXP;}
      break;
      }
    case FUNCTION_LN:{
      jj_consume_token(FUNCTION_LN);
{if ("" != null) return FunctionType.FUNCTION_LN;}
      break;
      }
    case FUNCTION_LOG:{
      jj_consume_token(FUNCTION_LOG);
{if ("" != null) return FunctionType.FUNCTION_LOG;}
      break;
      }
    case FUNCTION_SQRT:{
      jj_consume_token(FUNCTION_SQRT);
{if ("" != null) return FunctionType.FUNCTION_SQRT;}
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new IllegalStateException ("Missing return statement in function");
}

  final public Result Number() throws ParseException {Result value;
    Token t;
    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {
    case NUMBER_FP:{
      t = jj_consume_token(NUMBER_FP);
value = new Result(Double.parseDouble(t.image));
      break;
      }
    case NUMBER_INT:{
      t = jj_consume_token(NUMBER_INT);
      try {
          value = new Result(Long.parseLong(t.image));
      }
      catch(NumberFormatException n)
      {// FIND ME FIX
          value = new Result(Double.parseDouble(t.image));
      }
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return value;}
    throw new IllegalStateException ("Missing return statement in function");
}

  /** Generated Token Manager. */
  public CalculatorParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[11];
  static private int[] jj_la1_0;
  static {
	   jj_la1_init_0();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x180,0x180,0x200,0xc00,0xc00,0x1000,0x1ffa160,0x100,0x1ff8060,0x7f8000,0x60,};
	}

  /**
   * Constructor with InputStream and supplied encoding
   * @param stream input stream
   * @param encoding charset to be used. May not be <code>null</code>.
   */
  public CalculatorParser(final java.io.InputStream stream, final String encoding) {
   try {
     jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
   } catch(final java.io.UnsupportedEncodingException e) {
     throw new IllegalStateException(e);
   }
	 token_source = new CalculatorParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
  }

  /**
   * Reinitialise
   * @param stream input stream
   * @param encoding charset to be used. May not be <code>null</code>.
   */
  public void ReInit(final java.io.InputStream stream, final String encoding) {
	  try {
      jj_input_stream.reInit(stream, encoding, 1, 1);
    } catch(final java.io.UnsupportedEncodingException e) { 
      throw new IllegalStateException(e);
    }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
  }

  /**
   * Constructor with InputStream.
   * @param stream char stream
   */
  public CalculatorParser(final java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new CalculatorParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
   for (int i = 0; i < 11; i++)
     jj_la1[i] = -1;
  }

  /**
   * Reinitialise
   * @param stream char stream
   */
  public void ReInit(final java.io.Reader stream) {
	if (jj_input_stream == null) {
	  jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	  jj_input_stream.reInit(stream, 1, 1);
  }
	if (token_source == null) {
 token_source = new CalculatorParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
   for (int i = 0; i < 11; i++)
     jj_la1[i] = -1;
  }

  /**
   * Constructor with generated Token Manager.
   * @param tm Token manager to use
   */
  public CalculatorParser(final CalculatorParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
  }

  /**
   * Reinitialise
   * @param tm Token manager to use
   */
  public void ReInit(final CalculatorParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 11; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(final int kind) throws ParseException {
    final Token oldToken = token;
    if (token.next != null)
      token = token.next;
    else {
      token.next = token_source.getNextToken();
      token = token.next;
    }
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


  /**
   * @return the next Token.
   */
  public final Token getNextToken() {
   if (token.next != null)
     token = token.next;
   else
     token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

  /**
   * @param index index to be retrieved
   * @return the specific Token.
   */
  public final Token getToken(final int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next == null)
        t.next = token_source.getNextToken();
      t = t.next;
    }
    return t;
  }

  private int jj_ntk_f() {
    final Token nt = jj_nt = token.next;
    final int ret;
    if (nt == null) {
      token.next = token_source.getNextToken();
      ret = jj_ntk = token.next.kind;
    }
    else
      ret = jj_ntk = nt.kind;
    return ret;
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /**
   * Generate ParseException.
   * @return new Exception object. Never <code>null</code>
   */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[26];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 11; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 26; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /**
   * @return Always <code>false</code>.
   */
  public final boolean trace_enabled() {
    return false;
  }

  /** Enable tracing. */
  public final void enable_tracing() {}

  /** Disable tracing. */
  public final void disable_tracing() {}

}
